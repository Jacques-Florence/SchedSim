/**
@mainpage Scheduling simulator

@tableofcontents

@section intro Introduction

This is a scheduling simulator. It is capable of scheduling both real-time tasks and interactive tasks.
The simulator is able to simulate the power consumption as well as the resulting temperature of the processor.
The simulator allows for selecting the task scheduling algorithm as well as the frequency gopvernor policy.

@subsection taskModels Task models

The simulator does not schedule real tasks, but models of task behavior in terms of workload and power consumption. Let's look more closely at those models.

@subsubsection rt Real-Time tasks

Real-time tasks are modelled as an infinite sequence of jobs. Jobs are spawned at a regular interval.
Each job is defined as a set amount of work, where every job of the same task has the same amount of work. (WCET)

@subsubsection interactive Interactive processes

Interactive tasks are modelled as a sequence of workloads and waiting times. The waiting times model the time spent by the task waiting for user input, network, or disk access, etc.
The duration of waiting time, as well as the amount of work of each workload segment is random, following an exponential distribution.

@section install Installation

The scheduler is a set of static libraries.
To install, go to the src directory and run ./buildScript.sh.

The executable can be found in the folder build/ under the name simulator.
This will compile the libraries as well as an example use of the simulator.

@section use Using the simulator

@subsection firstSim My first simulation
As a first example, let's look at a very simple real-time scheduliong problem.
Let's consider two tasks. The first has a period of 15 and a worst-case execution time of 5.
The second task has a period of 20 and a wcet of 6.
Both tasks are assumed to be deterministic,
so that their execution time is always equal to their wcet.
We want to schedule this taskset under rate monotonic scheduling.

Let's take a look at the main function file:
@include docmain.cpp
The first step is to create a SchedulerConfiguration object,
initialized from a configuration file.
Then, we create a SchedulingSimulator object. This is the main object of the simulator.
Next, we can create the tasks. The easiest way is via the createRealTimeTask with four arguments:

- The time at which the task will first be ready
- The period at which the task repeats itself
- The amount of work to be done. Note that this is not a time duration.
The simulator is capable of varying frequency, so the time taken to complete a task is not fixed.
But for the moment, we will keep a constant frequency, the minimum frequency of the processor.
Therefore, we can specify the amount of work corresponding to a given time duration by multiplying the duration by the processor frequency.
- The deadline. Let's make this equal to the period of the task.

Next, we specify the time at which the processor should turn on. This value should be less than the starting time of the tasks.

Then, the function endSimulation() is used top specify at what time the simulation should end.
In this case, we get the value from the configuration file.

finally, we start the simulation.

Once the main file written, we can build the the simulator (see above).
We can now edit the configuration file, located in configuration/configuration.conf

@include configuration.conf
The most important field is the kind of task scheduler to use. In this case, it is rate-monotonic scheduling (rmsScheduler).

When executing the simulation with the -verbose option, a log is displayed:
@include demoOutput
it contains the list of all events, along with the time at which they occured.
For instance, both tasks spawn a new job at time 0.0.
At time 5.0, task with pid 0 terminates.
Whenever the task scheduler is invoked, the content of the ready queue is displayed.
It comprises the pid of the task as well as its amount of work.
It also prints the task currently being executed (or about to be).

@subsection conf Configuration file

A configuration file allows to parameterize the execution of the simulator. For instance, it allows selection of scheduling algorithm, frequency governor, running time, ...

The configuration file is necessary. The build script above automatically puts one in the folder of the executable.

@subsection taskgen taskset generation

@subsubsection hardcoded programatically
The first way to specify the taskset to simulate is to directly write it in C++ code, as we did in the first example.

@subsubsection random random

Another way to generate tasksets is to do it randomly.
First, make sure to replace the createRealTimeTask lines in the main function with the following line:
\code {C++}
simulator.initializeTaskSet();
\endcode
To generate the taskset randomly, you will also need to set up the configuration file as follows:
In the [taskSet] section, the tasksetSource entry should be set to random, and some values need to be specified:
\code
[taskSet]
tasksetSource = random
utilization = 0.7
nbOfTasks = 3
seed = 1234
priorities = no
powerSpan = 1.0
\endcode
the utilization field lets you specify the processor utilization of the task set.
nbOfTasks is the number of tasks.
The simulator will then generate a taskset where tasks have random periods and wcet.
Some other fields are required. The seed is the seed of the random generator that generates the taskset.
This allows you to generate a different taskset by changing the seed value.
By setting the priorities field to yes, the tasks will each have a different priority.
This characteristic is used by some scheduling algorithms.
Finally, powerSpan lets you specify the span of instantaneous power consumption of the different tasks (more on that later).


@subsubsection xml XML

Tasksets can also be specified via a configuration file. This allows tasksets to be changed without having to recompile the simulator.
Also, they provide a structured way to store or transfer taskset data.

An example of XML taskset is in the file xml/taskset.xml

*/
